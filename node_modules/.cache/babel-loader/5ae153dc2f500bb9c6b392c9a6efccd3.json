{"ast":null,"code":"import dates from './dates'; // assumes both are supported or none\n\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor() {\n    let {\n      culture = undefined,\n      firstOfWeek = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      dateStyle: 'short',\n      timeStyle: 'short'\n    };\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n\n}\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\n\n\nclass IntlNumberLocalizer {\n  constructor() {\n    let {\n      culture = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };","map":{"version":3,"names":["dates","supportStyles","Intl","DateTimeFormat","undefined","dateStyle","dateShort","day","month","year","timeShort","hour","minute","getFormatter","culture","options","format","IntlDateLocalizer","constructor","firstOfWeek","normalizeFormat","date","toLocaleString","formats","time","timeStyle","datetime","Object","assign","header","weekday","dayOfMonth","decade","endOf","century","keys","forEach","key","toFormattedParts","formatToParts","filter","p","type","parse","value","Date","isNaN","IntlNumberLocalizer","_$toLocaleString$m","decimal","NumberFormat","match","formatter","decimalCharacter","num","parseFloat","replace","DateLocalizer","NumberLocalizer"],"sources":["/home/kokegg/proyectoKaren/node_modules/react-widgets/esm/IntlLocalizer.js"],"sourcesContent":["import dates from './dates';\n// assumes both are supported or none\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor({\n    culture = undefined,\n    firstOfWeek = 0\n  } = {}) {\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, // @ts-ignore\n      supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date, format = {\n    dateStyle: 'short',\n    timeStyle: 'short'\n  }) {\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    const date = new Date(value);\n    return isNaN(+date) ? null : date;\n  }\n\n}\n\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\nclass IntlNumberLocalizer {\n  constructor({\n    culture = undefined\n  } = {}) {\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };"],"mappings":"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"},"metadata":{},"sourceType":"module"}